---
title: "TransformaÃ§Ã£o de dados"
subtitle: "IntroduÃ§Ã£o Ã  ciÃªncia de dados"
author: "Daniel Brito dos Santos"
format: 
  revealjs:
    incremental: false
---

## 4.1 IntroduÃ§Ã£o
- VisualizaÃ§Ã£o Ã© uma ferramenta importante para gerar insight, mas raramente os dados estÃ£o na **forma** que vocÃª precisa

::: {.incremental}
- Frequentemente precisamos:
    - **Criar** novas variÃ¡veis
    - Fazer **sumÃ¡rios** para achar padrÃµes importantes
    - **Renomear** variÃ¡veis 
    - **Reordenar** observaÃ§Ãµes para facilitar a manipulaÃ§Ã£o
:::

---

- Vamos aprender a fazer tudo isso usando o pacote **dplyr** e um novo dataset com os **voos** que sairam da cidade de **Nova York** em **2013**

- Nosso objetivo Ã© apresentar as principais ferramentas para **transformar** um data frame. 

- Vamos comeÃ§ar com operaÃ§Ãµes em **linhas**, depois em **colunas** e finalmente ver **grupos**

## 4.1.1 Prerequisitos
- O **dplyr** Ã© outro pacote fundamental do tidyverse
- Nosso dataset vai ser o **nycflights13** 

```r
library(nycflights13)
library(tidyverse)
#> â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.2 â”€â”€
#> âœ” ggplot2 3.4.0           âœ” purrr   1.0.1.9000 
#> âœ” tibble  3.1.8           âœ” dplyr   1.0.99.9000
#> âœ” tidyr   1.2.1.9001      âœ” stringr 1.5.0      
#> âœ” readr   2.1.3           âœ” forcats 0.5.2      
#> â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
#> âœ– dplyr::filter() masks stats::filter()
#> âœ– dplyr::lag()    masks stats::lag()
```

## 4.1.2 nycflights13
- Vamos usar o dataset *nycflights13::flights*
- Ele contÃ©m 336,776 voos que sairam da cidade de Nova York em 2013
- Primeiramente vamos dar uma espiadinha

---

Quais sÃ£o as formas de visualizar um data set em R? 

. . .

```r
flights 
```

. . .

```r
glimpse(flights) 
```

. . .

```r
view(flights) 
```

---

- Ã‰ interessante observamos as caracterÃ­sticas gerais dos nossos dados como
    - Nomes de colunas
    - Formato de dados 

---

```r
#| echo: true
glimpse(flights)
```

## 4.1.3 dplyr basics
- Vamos ver os **verbos bÃ¡sicos** que vÃ£o nos ajudar a resolver a maior parte dos desafios de **manipulaÃ§Ã£o de dados**

- Todos tem trÃªs coisas em comum:
    1. O **primeiro** argumento Ã© sempre um **data frame** (df)
    2. O **segundo** argumento descreve **o que fazer** com o df
    3. O **resultado** Ã© sempre um **novo df**

- Como o primeiro argumento e o resultado sÃ£o dfs, Ã© muito conveniente usarmos os pipes! (|>)
---

- O pipe pega o que estÃ¡ na esquerda e passa como primeiro argumento da funÃ§Ã£o depois dele:
```r
x |> f(y)
f(x, y)
```
. . .

Como seria nesse caso? 

```r
x |> f(y) |> g(z)
```
. . .

```r
g(f(x, y), z)f(x, y)
```
---
- Quem quer explicar esse cÃ³digo? SÃ³ um geralzÃ£o!
```r
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )
```
. . . 

- O cÃ³digo inicia com o dataset *fligths*, depois ele Ã© **filtrado**, **agrupado** e **sumarizado**.  

. . . 

- E os detalhes?

. . .

- Pegamos os voos, **filtramos** os destinados a "IAH". **Agrupamos** por ano, mes e dia. Finalmente, **sumarizamos** o seu atraso mÃ©dio. 

---

- Os verbos do dplyr sÃ£o organizados de acordo com o em que eles operam:
    - linhas, colunas, grupos ou tabelas
- Vamos ver os trÃªs primeiros casos, comeÃ§ando com 

## 4.2 Rows 
::: {.incremental}
- Os verbos mais importantes que operam em linhas sÃ£o:
    - *filter()* - que filtra as linhas desejadas 
    - *arrange()* - que muda a ordem das linhas 
    - NENHUM DOS DOIS MODIFICAM AS COLUNAS
- TambÃ©m temos: 
    - *distinct()* que encontra linhas com valores Ãºnicos, mas pode modificar colunas
:::

## *filter()*
::: {.incremental}
- Essa funÃ§Ã£o mantÃ©m as linhas baseado no valor de suas colunas
- O primeiro argumento Ã© um data frame
- Do segundo argumento em diante sÃ£o **condiÃ§Ãµes** que devem ser **verdadeiras** para **manter a linha**
:::
---

### Por exemplo

- Queremos encontrar todos os voos que chegaram mais de 120 minutos (duas horas) atrasados

- Quem arrisca? 

. . . 

```r
#| echo: true
flights |> 
  filter(arr_delay > 120)
```
---

- E se quisermos ver os voos que sairam dia primeiro de janeiro? 

. . .

```r
#| echo: true
flights |> 
  filter(month == 1 & day == 1)
```
---

- Voos que sairam em janeiro ou fevereiro? 

. . .

```r
#| echo: true
flights |> 
  filter(month == 1 | month == 2)
```
---

- Uma outra forma de fazer "em janeiro ou em fevereiro":
```r
#| echo: true
flights |> 
  filter(month %in% c(1, 2))
```
---

### Salvando o resultado
::: {.incremental}
- Quando executamos `filter()` o dplyr cria e retorna um novo data frame
- Ele **nÃ£o** modifica o input
- Por que funÃ§Ãµes *dplyr* **nunca** modificam os inputs 
- Para salvar o resultado precisamos usar o operador de atribuiÃ§Ã£o `<-`:
:::

. . .

```r
jan1 <- flights |> 
  filter(month == 1 & day == 1)
```

## 4.2.2 Erros comuns 

- No inÃ­cio Ã© fÃ¡cil confundir ``=`` com `==` quando queremos testar igualdade. 

. . .

- O que acham que vai acontecer?

```r
flights |> 
  filter(month = 1)
```
. . . 

```r
#> Error in `filter()`:
#> ! We detected a named input.
#> â„¹ This usually means that you've used `=` instead of `==`.
#> â„¹ Did you mean `month == 1`?
```
---

- Outro erro comum Ã© usar "ou" como usamos no dia a dia
```r
flights |> 
  filter(month == 1 | 2)
```
. . .

- O que acham que vai acontecer? 

. . . 

- Por que serÃ¡ que aconteceu isso? 

## `arrange()`
::: {.incremental}
- altera a **ordem** das linhas baseado no **valor** de suas **colunas** 
- recebe um **data frame** e um **conjunto** de **nomes de colunas** (ou expressÃµes) como **critÃ©rios** de ordenaÃ§Ã£o 
- Cada **novo argumento** Ã© usado para resolver **empates** na ordenaÃ§Ã£o do anterior
:::
---
### Exemplo
- O que esse cÃ³digo faz?
```r
flights |> 
  arrange(year, month, day, dep_time)
```
. . .

- **Ordena** por ordem de decolagem, que estÃ¡ separada nas quatro variÃ¡veis: ano, mÃªs, dia e hora da decolagem

```r
#> # A tibble: 336,776 Ã— 19
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     1     1      517      515       2     830     819      11 UA     
#> 2  2013     1     1      533      529       4     850     830      20 UA     
#> 3  2013     1     1      542      540       2     923     850      33 AA     
#> 4  2013     1     1      544      545      -1    1004    1022     -18 B6     
#> 5  2013     1     1      554      600      -6     812     837     -25 DL     
#> 6  2013     1     1      554      558      -4     740     728      12 UA     
#> # â€¦ with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```
---
<!-- ### Ordem decrescente -->
- O que acham que esse cÃ³digo faz?
```r
flights |> 
  arrange(desc(dep_delay))
```
. . .

- Podemos usar a funÃ§Ã£o `desc()` para reordenar a coluna em ordem decrescente

---

### Podemos combinar `arrange()` e `filter()` para resolver problemas mais complexos

. . .

- Exemplo:
  - como poderÃ­amos encontrar os voos que **chegaram** **mais atrasados**, mas que **decolaram** mais ou menos na **hora certa**? (esse Ã© mais difÃ­cil)

. . .

- Vamos deixar mais exato o "hora certa": 
    - voos que sairam com **atÃ©** 10 minutos de **atraso** ou **adiantamento** 
. . .

- (sim, eu tambÃ©m nÃ£o sabia que voos poderiam sair adiantados)

---

```r
flights |> 
  filter(dep_delay <= 10 & dep_delay >= -10) |> 
  arrange(desc(arr_delay))
#> # A tibble: 239,109 Ã— 19
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013    11     1      658      700      -2    1329    1015     194 VX     
#> 2  2013     4    18      558      600      -2    1149     850     179 AA     
#> 3  2013     7     7     1659     1700      -1    2050    1823     147 US     
#> 4  2013     7    22     1606     1615      -9    2056    1831     145 DL     
#> 5  2013     9    19      648      641       7    1035     810     145 UA     
#> 6  2013     4    18      655      700      -5    1213     950     143 AA     
#> # â€¦ with 239,103 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```

## 4.2.4 `distinct()`
::: {.incremental}
- **Encontra** todas as linhas **Ãºnicas** em um dataset
- Como os outros, seu primeiro argumento Ã© o dataset
- Seus prÃ³ximos argumentos sÃ£o os **nomes das colunas** que queremos as linhas distintas 
:::

--- 

- O que esse cÃ³digo faz? 
```r
flights |> 
  distinct(origin, dest)
```
. . .

```r
#> # A tibble: 224 Ã— 2
#>   origin dest 
#>   <chr>  <chr>
#> 1 EWR    IAH  
#> 2 LGA    IAH  
#> 3 JFK    MIA  
#> 4 JFK    BQN  
#> 5 LGA    ATL  
#> 6 EWR    ORD  
#> # â€¦ with 218 more rows
```
- Encontra todos os pares Ãºnicos de `origin` e `dest`

---

- E esse cÃ³digo? 
```r
flights |> 
  distinct()
```
. . . 

::: {.incremental}
- Se nÃ£o colocarmos nomes, ele **remove** as linhas **duplicadas**
- Pergunta: ele altera o dataset que recebeu de input?
- **nÃ£o!** Nenhum verbo dplyr altera o dataset original!
:::

<!-- ---

- Observe que se quisermos encontrar o nÃºmero de duplicatas, ou as linhas que nÃ£o foram duplicadas devemos substituir o `distict()` pelo `count()` e filtrar conformeo necessÃ¡rio -->

## 4.3 Columns 

::: {.incremental}
- Existem quatro verbos importantes que alteram as colunas sem alterar as linhas
  - `mutate()` - Cria novas colunas partindo de funÃ§Ãµes das colunas existentes
  - `select()` - Seleciona quais colunas manter no novo dataset
  - `rename()` - Renomea colunas 
  - `relocate()` - Altera a posiÃ§Ã£o das colunas
- TambÃ©m vamos discutir o `pull()` que permite obter uma coluna do dataset
:::

## `mutate()`
::: {.incremental}
- **Adiciona** novas colunas a partir da **manipulaÃ§Ã£o** das colunas existentes
- Nos capÃ­tulos de transformaÃ§Ã£o tem uma sÃ©rie de funÃ§Ãµes Ãºteis para manipular diferentes tipos de variÃ¡veis
- Aqui vamos focar na Ã¡lgebra bÃ¡sica 
::: 

---

### Computar o ``gain`` e ``speed``
- **gain**: quanto tempo um voo atrasado compensou no ar 
- **speed**: velocidade em milhas por hora

```r
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )
```
. . . 

- Viram as novas colunas? 

---

- Por padrÃ£o, o `mutate()` cria **novas colunas** na **extremidade direita** do dataset, fica difÃ­cil de ver no resumo

 . . .

- podemos usar o argumento `.before`:

```r
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )
```

---

- o `.` Ã© um sinal de que `.before` Ã© um argumento e nÃ£o uma nova variÃ¡vel

. . .

- TambÃ©m podemos usar `.after` e `.before` com variÃ¡veis:

```r
flights |> 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )
```
- O que faz esse cÃ³digo? 

. . .

- Cria as variÃ¡veis apos a variÃ¡vel `day`

---

### Argumento `.keep`
::: {.incremental}
- permite definirmos as **variÃ¡veis** que serÃ£o **mantidas**
- Ã‰ muito Ãºtil usar com o `"used"` para **manter** as variÃ¡veis **utilizadas** e **resultantes** do "mutaÃ§Ã£o"
:::

. . . 

```r
flights |> 
  mutate(,
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = "used"
  )
```

## 4.3.2 ``select()``
::: {.incremental}
- **Seleciona** um subgrupo de variÃ¡veis do dataset a partir dos seus nomes 
- Muito Ãºtil para datasets com centenas ou atÃ© milhares de colunas
- Vamos aos exemplos do seu funcionamento
:::

---

### Selecionar colunas pelos nomes
- Quem chuta a sintaxe para selecionarmos: `year`, `month` e `day`?

. . .

```r
flights |> 
  select(year, month, day)
#> # A tibble: 336,776 Ã— 3
#>    year month   day
#>   <int> <int> <int>
#> 1  2013     1     1
#> 2  2013     1     1
#> 3  2013     1     1
#> 4  2013     1     1
#> 5  2013     1     1
#> 6  2013     1     1
#> # â€¦ with 336,770 more rows
```

---

### Selecionar todas as colunas entre `year` e `day`

- e aÃ­?

. . .

```r
flights |> 
  select(year:day)
#> # A tibble: 336,776 Ã— 3
#>    year month   day
#>   <int> <int> <int>
#> 1  2013     1     1
#> 2  2013     1     1
#> 3  2013     1     1
#> 4  2013     1     1
#> 5  2013     1     1
#> 6  2013     1     1
#> # â€¦ with 336,770 more rows
```

---

- E o contrÃ¡rio? Como selecionar todas EXCETO entre `year` e `day`?

. . .

```r
flights |> 
  select(!year:day)
#> # A tibble: 336,776 Ã— 16
#>   dep_time sched_depâ€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier flight tailnum
#>      <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>    <int> <chr>  
#> 1      517         515       2     830     819      11 UA        1545 N14228 
#> 2      533         529       4     850     830      20 UA        1714 N24211 
#> 3      542         540       2     923     850      33 AA        1141 N619AA 
#> 4      544         545      -1    1004    1022     -18 B6         725 N804JB 
#> 5      554         600      -6     812     837     -25 DL         461 N668DN 
#> 6      554         558      -4     740     728      12 UA        1696 N39463 
#> # â€¦ with 336,770 more rows, 7 more variables: origin <chr>, dest <chr>,
#> #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,
#> #   time_hour <dttm>, and abbreviated variable names Â¹â€‹sched_dep_time,
#> #   Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```

---

### Selecionar todas as colunas que sÃ£o caracteres

. . .

```r
flights |> 
  select(where(is.character))
#> # A tibble: 336,776 Ã— 4
#>   carrier tailnum origin dest 
#>   <chr>   <chr>   <chr>  <chr>
#> 1 UA      N14228  EWR    IAH  
#> 2 UA      N24211  LGA    IAH  
#> 3 AA      N619AA  JFK    MIA  
#> 4 B6      N804JB  JFK    BQN  
#> 5 DL      N668DN  LGA    ATL  
#> 6 UA      N39463  EWR    ORD  
#> # â€¦ with 336,770 more rows
```

. . .

- `where()` Ã© uma "helper function" do `select()`

---

### outras helper functions do `select()`
::: {.incremental}
- ``starts_with("abc")``: corresponde aos nomes que comeÃ§am com â€œabcâ€
- ``ends_with("xyz")``: corresponde aos nomes que terminam com â€œxyzâ€
- `contains("ijk")`: corresponde aos nomes que contÃ©m â€œijkâ€
- `num_range("x", 1:3)`: corresponde com x1, x2 and x3.
- Para mais detalhes vejam consultem a documentaÃ§Ã£o:
  - `?select`
:::

---

### Podemos renomear as variÃ¡veis selecionadas 
- AlguÃ©m arrisca? Como mudar "tailnum" para "tail_num"?

. . .

```r
flights |> 
  select(tail_num = tailnum)
#> # A tibble: 336,776 Ã— 1
#>   tail_num
#>   <chr>   
#> 1 N14228  
#> 2 N24211  
#> 3 N619AA  
#> 4 N804JB  
#> 5 N668DN  
#> 6 N39463  
#> # â€¦ with 336,770 more rows
```

- novo_nome = nome_antigo


## 4.3.3 rename()
- se quiser manter as variÃ¡veis e apenas **renomar** algumas use ``rename()`` ao invÃ©s de ``select()``

- Quem vai? 

. . . 

```r
flights |> 
  rename(tail_num = tailnum)
#> # A tibble: 336,776 Ã— 19
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     1     1      517      515       2     830     819      11 UA     
[...]
```

- Funciona exatamente como `select()`, mas mantÃ©m **todas as variÃ¡veis**, nÃ£o apenas as explicitamente selecionadas

## 4.3.4 ``relocate()``
::: {.incremental}
- **Move** variÃ¡veis 
- Podemos querer deixar variÃ¡veis relacionadas prÃ³ximas, ou variÃ¡veis importantes mais pra esquerda
- Por padrÃ£o ele **trÃ¡s pra esquerda** as variÃ¡veis citadas
:::

. . .

```r
flights |> 
  relocate(time_hour, air_time)
#> # A tibble: 336,776 Ã— 19
#>   time_hour           air_time  year month   day dep_time sched_depâ€¦Â¹ dep_dâ€¦Â²
#>   <dttm>                 <dbl> <int> <int> <int>    <int>       <int>   <dbl>
#> 1 2013-01-01 05:00:00      227  2013     1     1      517         515       2
#> 2 2013-01-01 05:00:00      227  2013     1     1      533         529       4
#> 3 2013-01-01 05:00:00      160  2013     1     1      542         540       2
#> 4 2013-01-01 05:00:00      183  2013     1     1      544         545      -1
#> 5 2013-01-01 06:00:00      116  2013     1     1      554         600      -6
#> 6 2013-01-01 05:00:00      150  2013     1     1      554         558      -4
#> # â€¦ with 336,770 more rows, 11 more variables: arr_time <int>,
#> #   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>, flight <int>,
#> #   tailnum <chr>, origin <chr>, dest <chr>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, and abbreviated variable names Â¹â€‹sched_dep_time, Â²â€‹dep_delay
```

---

### TambÃ©m podemos usar os mesmos `.before` e `.after` que usamos em `mutate()`

- O que acham que esse cÃ³digo faz? 
```r
flights |> 
  relocate(year:dep_time, .after = time_hour)
```

---

```r
flights |> 
  relocate(year:dep_time, .after = time_hour)
#> # A tibble: 336,776 Ã— 19
#>   schedâ€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier flight tailnum origin dest 
#>     <int>   <dbl>   <int>   <int>   <dbl> <chr>    <int> <chr>   <chr>  <chr>
#> 1     515       2     830     819      11 UA        1545 N14228  EWR    IAH  
#> 2     529       4     850     830      20 UA        1714 N24211  LGA    IAH  
#> 3     540       2     923     850      33 AA        1141 N619AA  JFK    MIA  
#> 4     545      -1    1004    1022     -18 B6         725 N804JB  JFK    BQN  
#> 5     600      -6     812     837     -25 DL         461 N668DN  LGA    ATL  
#> 6     558      -4     740     728      12 UA        1696 N39463  EWR    ORD  
#> # â€¦ with 336,770 more rows, 9 more variables: air_time <dbl>,
#> #   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, year <int>,
#> #   month <int>, day <int>, dep_time <int>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```

- **realoca** todas as colunas de ``year`` atÃ© ``dep_time`` para depois de `time_hour`

---

- Como poderÃ­amos colocar as variÃ¡veis sobre a chegada do voo antes de `dep_time`?

. . .

- Estamos interessados nas variÃ¡veis que inicial com "arr", entÃ£o:

. . .

```r
flights |> 
  relocate(starts_with("arr"), .before = dep_time)
#> # A tibble: 336,776 Ã— 19
#>    year month   day arr_time arr_deâ€¦Â¹ dep_tâ€¦Â² schedâ€¦Â³ dep_dâ€¦â´ schedâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <dbl>   <int>   <int>   <dbl>   <int> <chr>  
#> 1  2013     1     1      830       11     517     515       2     819 UA     
#> 2  2013     1     1      850       20     533     529       4     830 UA     
#> 3  2013     1     1      923       33     542     540       2     850 AA     
#> 4  2013     1     1     1004      -18     544     545      -1    1022 B6     
#> 5  2013     1     1      812      -25     554     600      -6     837 DL     
#> 6  2013     1     1      740       12     554     558      -4     728 UA     
#> # â€¦ with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹arr_delay, Â²â€‹dep_time, Â³â€‹sched_dep_time, â´â€‹dep_delay, âµâ€‹sched_arr_time
```

# 4.4 Groups

## 4.4 Groups
- AtÃ© aqui aprendemos sobre funÃ§Ãµes que trabalham com **linhas** e **colunas**.
- O verdadeiro poder de dplyr Ã© te permitir trabalhar com **grupos**
- Vamos ver as duas funÃ§Ãµes mais importantes para isso: 
  - `group_by()` e `summarize()`

## 4.4.1 `group_by()`
::: {.incremental}
- **Divide** o datasets em grupos **significativos** para a anÃ¡lise 
- Vamos explicar com um exemplo
:::

. . .

```r
flights |> 
  group_by(month)
#> # A tibble: 336,776 Ã— 19
#> # Groups:   month [12]
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     1     1      517      515       2     830     819      11 UA     
#> 2  2013     1     1      533      529       4     850     830      20 UA     
#> 3  2013     1     1      542      540       2     923     850      33 AA     
#> 4  2013     1     1      544      545      -1    1004    1022     -18 B6     
#> 5  2013     1     1      554      600      -6     812     837     -25 DL     
#> 6  2013     1     1      554      558      -4     740     728      12 UA     
#> # â€¦ with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```
---

::: {.incremental}
- `group_by()` nÃ£o altera os dados, mas note que aparece "Groups: month"
- Isso significa que as **prÃ³ximas operaÃ§Ãµes** vÃ£o funcionar "**por mÃªs"**
- `group_by()` nÃ£o faz nada sozinho:
  - ele **altera** o <u>comportamento</u> dos **verbos subsequentes**
:::

## 4.4.2 `summarize()`
::: {.incremental}
- Ã© a operaÃ§Ã£o agrupada mais importante
- **reduz** <u>cada grupo</u> para uma **Ãºnica linha**
- Vamos ao exemplo! 
:::

---

- O que acham que esse cÃ³digo faz? 
```r
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay)
  )
```
. . .

- Ele vai **agrupar** nossos dados por mÃªs, em seguida **resumir** cada mÃªs pela **mÃ©dia** da variÃ¡vel `dep_delay` naquele mÃªs
- Testem! 

. . . 

- UÃ© ğŸ¤“

---

### O que deu errado? 
```r
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay)
  )
#> # A tibble: 12 Ã— 2
#>   month delay
#>   <int> <dbl>
#> 1     1    NA
#> 2     2    NA
#> 3     3    NA
#> 4     4    NA
#> 5     5    NA
#> 6     6    NA
#> # â€¦ with 6 more rows
```
::: {.incremental}
- NA Ã© contagioso, quase todas as operaÃ§Ãµes com NA resultam em NA. Se `dep_delay` tiver pelo menos um NA, sua mÃ©dia serÃ¡ NA
- Vamos corrigir removendo todas as NAs: `NA.rm = TRUE `
:::

---

- Onde acham que devemos colocar o `NA.rm = TRUE `?
```r
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay)
  )
```

. . .

```r
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE)
  )
#> # A tibble: 12 Ã— 2
#>   month delay
#>   <int> <dbl>
#> 1     1  10.0
#> 2     2  10.8
#> 3     3  13.2
#> 4     4  13.9
#> 5     5  13.0
#> 6     6  20.8
#> # â€¦ with 6 more rows
```
---

### `n()`
- retorna o **nÃºmero** de **linhas** em **cada** grupo
- podemos gerar a contagem e mÃ©dia no mesmo `summarize()`


```r
flights |> 
  group_by(month) |> 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n()
  )
#> # A tibble: 12 Ã— 3
#>   month delay     n
#>   <int> <dbl> <int>
#> 1     1  10.0 27004
#> 2     2  10.8 24951
#> 3     3  13.2 28834
#> 4     4  13.9 28330
#> 5     5  13.0 28796
#> 6     6  20.8 28243
#> # â€¦ with 6 more rows
```

---

- Existem outros tipos de sumÃ¡rios, mas nesta parte do livro focamos nesses dois. Segundo o Whikham:

> Means and counts can get you a surprisingly long way in data science!

## 4.4.3 As funÃ§Ãµes `slice_`
::: {.incremental}
- cinco funÃ§Ãµes Ãºteis para especificar **quais linhas** pegar de **cada grupo**
  - `df |> slice_head(n = 1)` pega a **primeira** linha de cada grupo
  - `df |> slice_tail(n = 1)` pega a **Ãºltima** linha de cada grupo
:::

---

::: {.incremental}
  - `df |> slice_min(x, n = 1)` pega a linha com o **menor** valor de `x`
  - `df |> slice_max(x, n = 1)` pega a linha com o **maior** valor de `x`
  - `df |> slice_sample(n = 1)` pega uma linha **aleatÃ³ria** de cada grupo
- Podemos variar o `n = ` para pegar **mais de uma** linha
  - Podemos substituir pelo `prop = 0.1` para pegar 10% das linhas de cada grupo 
:::

---

### Exemplo
- Como podemos encontrar os voos **mais** atrasados para cada destino?

. . .

```r
flights |> 
  group_by(dest) |> 
  slice_max(arr_delay, n = 1)
#> # A tibble: 108 Ã— 19
#> # Groups:   dest [105]
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     7    22     2145     2007      98     132    2259     153 B6     
#> 2  2013     7    23     1139      800     219    1250     909     221 B6     
#> 3  2013     1    25      123     2000     323     229    2101     328 EV     
#> 4  2013     8    17     1740     1625      75    2042    2003      39 UA     
#> 5  2013     7    22     2257      759     898     121    1026     895 DL     
#> 6  2013     7    10     2056     1505     351    2347    1758     349 UA     
#> # â€¦ with 102 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```

## 4.4.4 Agrupando por mÃºltiplas variÃ¡veis

::: {.incremental}
- Podemos criar grupos usando mais de uma variÃ¡vel
- Ex: criar um grupo pra cada dia. Quem chuta?
:::

. . .

```r
daily <- flights |>  
  group_by(year, month, day)
daily
#> # A tibble: 336,776 Ã— 19
#> # Groups:   year, month, day [365]
#>    year month   day dep_time sched_â€¦Â¹ dep_dâ€¦Â² arr_tâ€¦Â³ schedâ€¦â´ arr_dâ€¦âµ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     1     1      517      515       2     830     819      11 UA     
#> 2  2013     1     1      533      529       4     850     830      20 UA     
#> 3  2013     1     1      542      540       2     923     850      33 AA     
#> 4  2013     1     1      544      545      -1    1004    1022     -18 B6     
#> 5  2013     1     1      554      600      -6     812     837     -25 DL     
#> 6  2013     1     1      554      558      -4     740     728      12 UA     
#> # â€¦ with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   Â¹â€‹sched_dep_time, Â²â€‹dep_delay, Â³â€‹arr_time, â´â€‹sched_arr_time, âµâ€‹arr_delay
```
---

### Um detalhe 
- Quando sumarizamos um tibble agrupado por mais de uma variÃ¡vel, o sumÃ¡rio ignora o Ãºltimo agrupamento
- A prÃ³pria funÃ§Ã£o avisa desse comportamento contraintuitivo e diz como mudar

```r
daily_flights <- daily |> 
  summarize(
    n = n()
  )
#> `summarise()` has grouped output by 'year', 'month'. You can override using
#> the `.groups` argument.
```

---

- Testem o `.groups = ` com seus principais argumentos (`drop_last`, `keep`. `drop`)
- O que cada um faz? 

```r
daily_flights <- daily |> 
  summarize(
    n = n(), 
    .groups = "drop_last"
  )
```

---

- Com o `.groups` podemos usar:
  - `drop_last` para ignorar o Ãºltimo agrupamento, como o padrÃ£o
  - `keep` para manter todos os grupos
  - `drop` para ignorar todos os grupos


## 4.4.5 Desagrupar
- `ungroup()` remove os grupos 

- Qual vocÃªs acham que Ã© o resultado desse cÃ³digo? 

```r
daily |> 
  ungroup() |>
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )
```

. . . 

- Rodem. O que aconteceu? Ã‰ o que esperavam? 

. . .

```r
#> # A tibble: 1 Ã— 2
#>   delay flights
#>   <dbl>   <int>
#> 1  12.6  336776
```

- Quando sumarizamos um data frame desagrupado o dplyr trata como se fosse um grupo sÃ³ 


## 4.6 SumÃ¡rio
::: {.incremental}
- Neste capÃ­tulo aprendemos ferramentas do dplyr para trabalhar com data frames. Vimos ferramentas para manipular:
- linhas (filter() e arrange())
- colunas (select() e mutate())
- e grupos (group_by() e summarize()).
- Nosso enfoque nessas ferramentas gerais Ã© um excelente ponto de partida para seguir aprendendo!

- Quem tiver interesse pode ler o capÃ­tulo de transformaÃ§Ãµes ou jÃ¡ sair no soco com um dataframe! 
:::

# DÃºvidas? 

<!-------------------------------- -->
